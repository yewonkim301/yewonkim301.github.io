---
title: "[백준 2531] 회전초밥 - JAVA(자바)"
date: 2025-08-26
categories: [알고리즘]
tags: [알고리즘, 백준]
image:
  path: /assets/img/기본형3_java.png
---

### 문제

- [[백준] 2531](https://www.acmicpc.net/problem/2531)

![img](/assets/img/algorithm/백준2531_1.png)
![img](/assets/img/algorithm/백준2531_2.png)
<br /><br />

### 해결방법
- **투 포인터** 활용하기
  - **슬라이딩 윈도우** 활용하기
    - 한 칸씩 윈도우를 옮길 때 `빠지는 초밥`과 `새로 들어오는 초밥`만 업데이트
    - `ate[]` 배열에 몇 번 초밥을 몇 개 먹었는지 저장
    - `ate[스시 번호] == 0`이면 처음 먹는 스시 종류이므로 `diff++`
    - `ate[c] == 0`이면 쿠폰 번호의 초밥을 먹은 적이 없으므로 `diff+1`


<br /><br />

### 코드

```java
import java.util.*;
import java.lang.*;
import java.io.*;

class Main {
    private static int n, d, k, c;
    private static int[] sushi;
    private static int[] ate;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        d = Integer.parseInt(st.nextToken());
        k = Integer.parseInt(st.nextToken());
        c = Integer.parseInt(st.nextToken());
        sushi = new int[n];
        ate = new int[d+1];

        for (int i = 0; i < n; i++) {
            sushi[i] = Integer.parseInt(br.readLine());
        }

        int diff = 0;

        for (int i = 0; i < k; i++) {
            if (ate[sushi[i]] == 0) diff++;
            ate[sushi[i]]++;
        }

        int max = ate[c] == 0 ? diff+1 : diff;

        for (int start = 1; start < n; start++) {
            // 앞에 접시 빼기
            ate[sushi[start-1]]--;
            if (ate[sushi[start-1]] == 0) diff--;
            // 뒤에 접시 추가
            int end = (start + k - 1) % n;
            if (ate[sushi[end]] == 0) diff++;
            ate[sushi[end]]++;
            // 쿠폰 번호인지 확인
            int cur = ate[c] == 0 ? diff+1 : diff;
            // 최댓값
            max = Math.max(max, cur);
        }
        
        System.out.println(max);
    }
}
```