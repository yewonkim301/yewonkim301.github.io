---
title: "[백준 2193] 이친수"
date: 2025-08-19
categories: [알고리즘]
tags: [알고리즘, 백준]
image:
  path: /assets/img/기본형3_java.png
---

### 문제

- [[백준] 2193](https://www.acmicpc.net/problem/2193)

![img](/assets/img/algorithm/백준2193.png)
<br /><br />

### 해결방법
- **DP(다이나믹 프로그래밍)** 활용하기
    - N자리 이친수는 마지막 자리 숫자에 따라 두 가지 경우로 나눌 수 있음
        - 마지막 자리가 0인 경우
            - 마지막 0을 떼면, 앞의 (N-1)자리 이친수가 됨.<br />
              → 경우의 수 = dp[i-1]
        - 마지막 자리가 1인 경우
            - 1이 두 번 연속 안 나와야 하므로, 마지막 1 앞에는 반드시 0이 와야 함.<br />
              즉, 마지막 두 자리는 01이고, 앞의 (N-2)자리 이친수가 됨.<br />
              → 경우의 수 = dp[i-2]<br />
        **→ 따라서 총 경우의 수 = dp[i-1] + dp[i-2]**
- `N ≤ 90`이므로 `dp`의 타입은 **long**
  - 예를 들어, `N=90`이면 피보나치 수 dp[90]는 약 2×10¹⁸ 정도가 된다.
  - 하지만 int 타입은 최대 약 2×10⁹까지만 표현 가능하므로 오버플로우가 발생한다.


  


<br /><br />

### 코드

```java
import java.util.*;
import java.lang.*;
import java.io.*;

class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());

        int[] dp = new int[n+1];
        dp[1] = 1;
        if(n >= 2) dp[2] = 1;
        for (int i = 3; i <= n; i++) { 
            dp[i] = dp[i-1] + dp[i-2]; 
        }
        
        System.out.println(dp[n]);
    }
}
```