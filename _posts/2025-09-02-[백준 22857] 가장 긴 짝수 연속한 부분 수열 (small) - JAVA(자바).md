---
title: "[백준 22857] 가장 긴 짝수 연속한 부분 수열 (small) - JAVA(자바)"
date: 2025-09-02
categories: [알고리즘]
tags: [알고리즘, 백준]
image:
  path: /assets/img/기본형3_java.png
---

### 문제

- [[백준] 22857](https://www.acmicpc.net/problem/22857)

![img](/assets/img/algorithm/백준22857.png)
<br /><br />

### 해결방법
- **투 포인터** 활용하기
  - **슬라이딩 윈도우** 활용하기
    - **홀수 개수가 k개 이하인 구간**을 유지하면서, 구간의 최대 길이를 갱신
    - 윈도우 확장 : `end` 포인터를 이동시키면서, 홀수인 경우 개수를 증가시키고, 홀수 개수가 k개 이하인 경우 최대 길이 갱신
    - 윈도우 축소 : 홀수 개수가 k개 이상이 되는 경우 `start` 포인터를 이동시키면서, 홀수인 경우 개수를 감소시키고, 홀수 개수가 k개 이하가 될 때까지 반복

<br /><br />

### 코드

```java
import java.util.*;
import java.lang.*;
import java.io.*;

class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());

        int[] arr = new int[n];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }

        int start = 0; 
        int answer = 0;
        int cnt = 0;

        for (int end = 0; end < n; end++) {
            if (arr[end] % 2 != 0) cnt++;

            while (cnt > k) {
                if (arr[start] % 2 != 0) cnt--;
                start++;
            }

            answer = Math.max(answer, end-start+1-cnt);
        }
        
        System.out.println(answer);
    }
}
```