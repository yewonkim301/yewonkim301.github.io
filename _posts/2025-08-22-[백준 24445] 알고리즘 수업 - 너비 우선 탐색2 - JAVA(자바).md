---
title: "[백준 3184] 양 - JAVA(자바)"
date: 2025-08-24
categories: [알고리즘]
tags: [알고리즘, 백준]
image:
  path: /assets/img/기본형3_java.png
---

### 문제

- [[백준] 3184](https://www.acmicpc.net/problem/3184)

![img](/assets/img/algorithm/백준3184_1.png)
![img](/assets/img/algorithm/백준3184_2.png)
<br /><br />

### 해결방법
- **DFS(깊이 우선 탐색)** 활용하기
    - 입력으로 주어진 맵을 2차원 배열로 저장한다
    - 각 칸을 방문하면서, 울타리(`#`)가 아닌 칸에 대해 DFS를 수행하여 양(`o`)과 늑대(`v`)의 수를 센다
    - 한 구역 내에서 양의 수가 늑대의 수보다 많으면 양의 수를 전체 양의 수에 더하고, 그렇지 않으면 늑대의 수를 전체 늑대의 수에 더한다

<br /><br />

### 코드

```java
import java.util.*;
import java.lang.*;
import java.io.*;


class Main {
    private static int r, c;
    private static char[][] map;
    private static boolean[][] visited;
    private static int sumSheep = 0;
    private static int sumWolf = 0;
    private static int sheep, wolf;
    private static int[] dx = {1, -1, 0, 0};
    private static int[] dy = {0, 0, 1, -1};
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        r = Integer.parseInt(st.nextToken());
        c = Integer.parseInt(st.nextToken());
        map = new char[r][c];
        visited = new boolean[r][c];

        for (int i = 0; i < r; i++) {
            String str = br.readLine();
            for (int j = 0; j < c; j++) {
                map[i][j] = str.charAt(j);
            }
        }

        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                if (!visited[i][j] && map[i][j] != '#') {
                    sheep = 0;
                    wolf = 0;
                    dfs(i, j);
                    if (sheep > wolf) sumSheep += sheep;
                    else sumWolf += wolf;
                }
            }
        }
        System.out.println(sumSheep + " " + sumWolf);
    }
    private static void dfs (int x, int y) {
        if (map[x][y] == 'o') sheep++;
        else if (map[x][y] == 'v') wolf++;

        visited[x][y] = true;

        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx < 0 || nx >= r || ny < 0 || ny >= c) continue;
            if (!visited[nx][ny] && map[nx][ny] == '#') {
                visited[nx][ny] = true;
                continue;
            }

            if (!visited[nx][ny] && map[nx][ny] != '#') {
                dfs(nx, ny);
            }
        }
    }
}
```