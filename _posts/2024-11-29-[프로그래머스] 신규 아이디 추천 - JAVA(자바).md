---
title: "[프로그래머스] 신규 아이디 추천 - JAVA(자바)"
date: 2024-11-29
categories: [알고리즘]
tags: [99클럽, 코딩테스트준비, 개발자취업, 항해99, TIL, 알고리즘, 프로그래머스, 시뮬레이션]
image:
  path: /assets/img/기본형3_java.png
---

### 문제
![img](/assets/img/algorithm/프로그래머스_신규아이디추천1.png)
![img](/assets/img/algorithm/프로그래머스_신규아이디추천2.png)
<br /><br />

### 해결방법
- **정규표현식** 활용하기

<br />

#### # 정규표현식이란?

![img](/assets/img/til/정규표현식.png)

- 문자열 데이터 중에서 원하는 조건(패턴)과 일치하는 문자열 부분을 찾아내기 위해 사용하는 것으로 미리 정의된 기호와 문자를 이용해서 작성한 문자열을 말한다.

- 전화번호, 주민등록번호, 이메일 등과 같이 정해져 있는 형식이 있고 사용자가 그 형식대로 제대로 입력했는지 검증을 해야하는 경우가 종종 있다. 이런 입력값을 정해진 형식에 맞는지 검증해야 할 때에는 정규표현식을 사용하면 쉽게 구현할 수 있다.

<br />

#### # 정규식 문법 기호 모음

##### 1. 정규식 기본 기호

| 기호    | 설명                                                                                      | 예제                                        |
|---------|-------------------------------------------------------------------------------------------|---------------------------------------------|
| `.`     | 임의의 문자 1개를 의미                                                                    | `a.` : a로 시작하는 단어                   |
| `^`     | 시작을 의미한다.                                                                          | `^a` : a로 시작하는 단어                   |
|         | `^`가 대괄호 안에 있으면 일치하지 않는 부정의 의미로 쓰인다.                              | `[^a]` : a가 아닌 첫 번째 문자             |
| `$`     | 앞의 문자열로 끝나는지를 의미한다.                                                        | `a$` : a로 끝나는 단어                     |
| `[]`    | 대괄호 안의 문자가 있는지 확인한다.                                                      | `[ab][cd]` : a, b 중 하나 + c, d 중 하나   |
| `[^]`   | 대괄호 안에 문자가 없으면, 제외된 뜻을 담는다.                                            | `[^a-z]` : 알파벳 소문자 이외의 문자       |
| `-`     | 사이에 문자를 숫자를 의미한다.                                                            | `[a-z]` : 알파벳 소문자 전체               |
| `|`     | 또는                                                                                     | `[a|b]` : a 혹은 b                         |
| `()`    | 그룹                                                                                     | `01(1)?` : 01 뒤에 1이 들어갈 수도 있음    |
| `{}`    | 개수                                                                                     | `a{3}` : a가 3번 연속 등장                 |
| `\s`    | 공백, 탭, `\n`, `\r` 등을 의미                                                           | `apple\s` : apple 뒤에 공백이 있음         |
| `\S`    | 공백, 탭이 아닌 문자                                                                     |                                             |
| `\b`    | 단어 경계                                                                                | `apple\b` : apple 뒤가 단어 경계           |
| `\B`    | 단어 경계가 아님                                                                         |                                             |
| `\d`    | 숫자 (0-9)와 동일                                                                        | `[0-9]`와 동일                             |
| `\D`    | 숫자가 아닌 문자                                                                         | `[^\d]`와 동일                             |
| `\w`    | 알파벳 대소문자, 숫자, 밑줄                                                              | `[a-zA-Z_0-9]`와 동일                      |
| `\W`    | 알파벳 대소문자, 숫자, 밑줄이 아닌 문자                                                  | `[^\w]`와 동일                             |


☞  주의 : 

점(`.`)은 정규 표현식에서 특별한 의미를 가지고 있으며, 모든 문자를 의미한다. 점(`.`)을 문자 그대로 사용하려면 이스케이프 처리가 필요하다. 정규 표현식에서 점(`.`)을 문자 그대로 인식시키기 위해서는 백슬래시(`\.`)를 사용해야 한다.

자바에서는 문자열에서 백슬래시(`\`) 자체를 표현하려면 이스케이프하여 `\\`로 써야 한다. 따라서 정규 표현식에서 점(`.`)을 나타내기 위해서는 `\\.`으로 표기해야 한다.

```java
today.split("\\."); // . 을 기준으로 분할
```

##### 2. 정규식 수량 기호

| 기호 | 설명 | 예제 |
| --- | --- | --- |
| ? | 앞의 표현식이 없거나 or 최대 한 개만 | `a1?` : 1이 최대 한 개만 있거나 없을수도 있다.
→ a(o), a1(o), a11(x), a111(x) |
| * | 앞의 표현식이 없거나 or 있거나*(여러개) | `a1*` : 1이 있을수도 없을수도 있다.
→ a(o), a1(o), a11(o), a111(o) |
| + | 앞의 표현식이 1개 이상 or 여러개 | `a1+` : 1이 1개 이상 있다.
→ a(x), a1(o), a11(o), a111(o) |
| {n} | 딱 n개 있다. | `a{3}` : a가 딱 3개 있다.
→ aa(x), aaa(o), aaaa(x), aaaaaaa(x) |
| {n, m} | n개 이상 m개 이하 | `a{3,5}` : a가 3개 이상 5개 이하 있다.
→ aa(x), aaa(o), aaaa(o), aaaaaa(x) |
| {n,} | n개 이상 | `a{3,}` : a가 3개 이상 있다.
→ aa(x), aaa(o), aaaa(o), aaaaaa(o) |

<br />

##### 3. 정규식 그룹 캡쳐 기호

| 기호 | 설명 |
| --- | --- |
| () | 그룹 및 캡쳐 |
| (?:) | 찾지만 그룹에 포함 안됨 |
| (?=) | = 앞 문자를 기준으로 전방 탐색 |
| (?<=) | = 뒤 문자를 기준으로 후방 탐색 |

<br />

##### 4. 자주 사용되는 정규식 샘플

| 기호 | 설명 |
| --- | --- |
| ^[0-9]*$ | 숫자 |
| ^[a-zA-Z]*$ | 영문자 |
| ^[가-힣]*$ | 한글 |
| \\w+@\\w+\\.\\w+(\\.\\w+)? | E-Mail |
| ^\d{2,3}-\d{3,4}-\d{4}$ | 전화번호 |
| ^01(?:0|1|[6-9])-(?:\d{3}|\d{4})-\d{4}$ | 휴대전화번호 |
| \d{6} \- [1-4]\d{6} | 주민등록번호 |
| ^\d{3}-\d{2}$ | 우편번호 |

<br />

#### # 자바 정규식 문법

<aside>
💡 **String 클래스의 정규식 문법**
String 문자열에 바로 정규표현식을 적용하여 필터링이 가능하다.

</aside>

| String 정규식 메서드 | 설명 |
| --- | --- |
| boolean matches(String regex) | 인자로 주어진 정규식에 매칭되는 값이 있는지 확인 |
| String replaceAll(String regex, String replacement) | 문자열 내에 있는 정규식 regex와 매치되는 모든 문자열을 replacement 문자열로 바꾼 문자열을 반환 |
| String[] split(String regex) | 인자로 주어진 정규식과 매치되는 문자열을 구분자로 분할 |

```java
// 1. matches : 일치하는지 확인
String txt = "123456";
boolean result1 = txt.matches("[0-9]+"); // 숫자로 이루어져있는지
System.out.println(result1); // true

// 2. replaceAll : 정규표현식과 일치하는 모든 값 치환
String txt2 = "power987*-;";
String result2 = txt2.replaceAll("[^a-z0-9]", "0"); // 영문자와 숫자를 제외한 문자를 모두 0으로 치환
System.out.println(result2); // power987000

// 3. split : 정규표현식과 일치하는 값 기준으로 나누기
String txt3 = "power987*-;";
String[] txts = txt3.split("[0-9]+"); // 숫자 부분을 기준으로 분할
System.out.println(txts[0]); // power
System.out.println(txts[1]); // *-;
```


<br /><br />

### 코드
```
class Solution {
    public String solution(String new_id) {
        
        // step1
        new_id = new_id.toLowerCase();
        
        // step2
        new_id = new_id.replaceAll("[^-_.a-z0-9]", "");
        
        // step3
        new_id = new_id.replaceAll("[.]{2,}", ".");
        
        // step4
        new_id = new_id.replaceAll("^[.]|[.]$", "");
        
        // step5
        if (new_id.equals("")) new_id = "a";
        
        // step6
        if (new_id.length() >= 16) {
            new_id = new_id.substring(0, 15);
            new_id = new_id.replaceAll("[.]$", "");
        }
        
        // step7
        if (new_id.length() <= 2) {
            while (new_id.length() < 3) {
                new_id += new_id.charAt(new_id.length() - 1);
            }
        }
        
        return new_id;
    }
}
```
 
