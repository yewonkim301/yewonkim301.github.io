---
title: "[백준 2961] 도영이가 만든 맛있는 음식 - JAVA(자바)"
date: 2025-09-05
categories: [알고리즘]
tags: [알고리즘, 백준]
image:
  path: /assets/img/기본형3_java.png
---

### 문제

- [[백준] 2961](https://www.acmicpc.net/problem/2961)

![img](/assets/img/algorithm/백준2961_1.png)
![img](/assets/img/algorithm/백준2961_2.png)
<br /><br />

### 해결방법
- **백트래킹** 활용하기
    - 재료의 개수가 최대 10개이므로, 모든 재료의 부분집합을 구하는 방법으로 접근
    - 재료의 부분집합을 구하면서, 신맛과 쓴맛의 차이의 최솟값을 갱신
    - 부분집합을 구하는 방법은 DFS를 활용

<br /><br />

### 코드

```java
import java.util.*;
import java.lang.*;
import java.io.*;

class Main {
    static int n;
    static int[][] ingredients;
    static int min = Integer.MAX_VALUE;
    static boolean[] visited;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        n = Integer.parseInt(br.readLine());
        ingredients = new int[n][2];
        visited = new boolean[n];

        for (int i = 0; i < n; i++){
            StringTokenizer st = new StringTokenizer(br.readLine());
            ingredients[i][0] = Integer.parseInt(st.nextToken());
            ingredients[i][1] = Integer.parseInt(st.nextToken());
        }

        for (int i = 0; i < n; i++) {
            dfs(i+1, 0, 1, 0);
        }
        
        System.out.println(min);
    }

    private static void dfs(int depth, int choose, int s, int b) {
        if (depth == choose) {
            min = Math.min(min, Math.abs(s-b));
            return;
        }

        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                visited[i] = true;
                dfs(depth, choose+1, s*ingredients[i][0], b+ingredients[i][1]);
                visited[i] = false;
            }
        }
        
    }
}
```