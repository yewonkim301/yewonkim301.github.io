---
title: "[백준 11057] 오르막 수 - JAVA(자바)"
date: 2025-08-25
categories: [알고리즘]
tags: [알고리즘, 백준]
image:
  path: /assets/img/기본형3_java.png
---

### 문제

- [[백준] 11057](https://www.acmicpc.net/problem/11057)

![img](/assets/img/algorithm/백준11057.png)
<br /><br />

### 해결방법
- **DP(다이나믹 프로그래밍)** 활용하기
  - 오르막 수의 길이 n과 끝자리 수 j에 대해 dp[n][j]를 정의
    - dp[n][j]는 길이 n인 오르막 수 중에서 마지막 자리가 j인 수의 개수를 나타냄
  - 길이가 1인 오르막 수는 0부터 9까지 각각 하나씩 존재하므로 dp[1][j] = 1 (0 ≤ j ≤ 9)
  
    |  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | total 오르막 수 |
    | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
    | `n = 1` | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 10 |
    | `n = 2` | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 55 |
    | `n = 3` | 1 | 3 | 6 | 10 | 15 | 21 | 28 | 36 | 45 | 55 | 220 |
   → 따라서, 점화식은 다음과 같다
    - `dp[n][j] = dp[n-1][0] + dp[n-1][1] + ... + dp[n-1][j]`
  - 최종적으로 길이 n인 오르막 수의 개수는 dp[n][0] + dp[n][1] + ... + dp[n][9]가 됨


<br /><br />

### 코드

```java
import java.util.*;
import java.lang.*;
import java.io.*;

class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        long[][] dp = new long[n+1][10]; // [n자리수][끝자리 수]
        for (int i = 0; i < 10; i++) {
            dp[1][i] = 1;
        }

        for (int i = 2; i <= n; i++) {
            for (int j = 0; j < 10; j++) {
                for (int k = 0; k <= j; k++) {
                    dp[i][j] += dp[i-1][k];
                }
                dp[i][j] %= 10007;
            }
        }

        long answer = 0;
        for (int i = 0; i < 10; i++) {
            answer += dp[n][i];
        }
        
        System.out.println(answer % 10007);
    }
}
```