---
title: "[백준 13565] 침투 - JAVA(자바)"
date: 2025-09-17
categories: [알고리즘]
tags: [알고리즘, 백준]
image:
  path: /assets/img/기본형3_java.png
---

### 문제

- [[백준] 13565](https://www.acmicpc.net/problem/13565)

![img](/assets/img/algorithm/백준13565_1.png)
![img](/assets/img/algorithm/백준13565_2.png)
<br /><br />

### 해결방법
- **깊이우선탐색(DFS)** 활용하기
  - 0으로 이루어진 영역이 상단에서 하단까지 연결되어 있는지 확인하는 문제
  - 상단에서 시작하여 0인 부분을 따라가며 DFS를 수행
  - 만약 하단에 도달하면(`x = m-1`) `"YES"` 출력, 그렇지 않으면 `"NO"` 출력
    
<br /><br />

### 코드

```java
import java.util.*;
import java.lang.*;
import java.io.*;

class Main {
    static int m, n;
    static char[][] map;
    static boolean[][] visited;
    static boolean isPossible = false;
    static int[] dx = {1, -1, 0, 0};
    static int[] dy = {0, 0, 1, -1};
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        m = Integer.parseInt(st.nextToken());
        n = Integer.parseInt(st.nextToken());
        map = new char[m][n];
        visited = new boolean[m][n];

        for (int i = 0; i < m; i++) {
            String str = br.readLine();
            for (int j = 0; j < n; j++) {
                map[i][j] = str.charAt(j);
            }
        }

        for (int i = 0; i < n; i++) {
            if (map[0][i] == '0' && !visited[0][i]) {
                visited[0][i] = true;
                dfs(0, i);
            }
            if (isPossible) {
                System.out.println("YES");
                return;
            }
        }
        
        System.out.println("NO");
    }

    private static void dfs (int x, int y) {
        if (x == m-1) {
            isPossible = true;
            return;
        }

        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx < 0 || nx >= m || ny < 0 || ny >= n) continue;
            if (!visited[nx][ny] && map[nx][ny] == '0') {
                visited[nx][ny] = true;
                dfs(nx, ny);
                if (isPossible) break;
            }
        }
    }
}
```