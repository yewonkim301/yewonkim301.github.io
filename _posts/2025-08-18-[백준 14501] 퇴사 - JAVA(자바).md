---
title: "[백준 14501] 퇴사 - JAVA(자바)"
date: 2025-08-18
categories: [알고리즘]
tags: [알고리즘, 백준]
image:
  path: /assets/img/기본형3_java.png
---

### 문제

- [[백준] 14501](https://www.acmicpc.net/problem/14501)

![img](/assets/img/algorithm/백준14501_1.png)
![img](/assets/img/algorithm/백준14501_2.png)
<br /><br />

### 해결방법
- **DP(다이나믹 프로그래밍)** 활용하기
    - 각 상담의 기간과 수익을 고려하여, 해당 상담을 선택했을 때의 최대 수익을 계산한다.
    - `dp[i]`는 `i`번째 날까지의 최대 수익을 저장한다.
        → 즉 `i`에 새상담을 시작할 수 있는 상태에서의 최대 누적 수익
    - 각 날에 대해, 해당 날에 상담을 진행할 수 있는지 확인하고, 가능하다면 최대 수익을 갱신한다.
      - (1) **상담을 수행하는 경우**
        -  i일 상담을 하면 t[i]일이 걸려 끝나는 날 = i + t[i]
        -  그때의 최대 이익 = dp[i] + p[i]
        -  따라서 dp[i + t[i]] = max(dp[i + t[i]], dp[i] + p[i])
        👉 상담을 하면 끝나는 날 칸에 이익을 누적해야 이후 스케줄과 자연스럽게 연결됨
     - (2) **상담을 건너뛰는 경우**
        -  i일까지 벌어둔 최대 이익은 i+1일에도 그대로 유효
        -  따라서 dp[i + 1] = max(dp[i + 1], dp[i])
        👉 상담을 안 해도 이전 이익을 다음 날로 흘려보내야 최적해를 놓치지 않을 수 있음

  


<br /><br />

### 코드

```java
import java.util.*;
import java.lang.*;
import java.io.*;

class Main {
    private static int n;
    private static int[] t;
    private static int[] p;
    private static int[] dp;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        n = Integer.parseInt(br.readLine());
        t = new int[n];
        p = new int[n];
        dp = new int[n+1];
        
        StringTokenizer st;
        for (int i = 0; i < n; i++) {
            st = new StringTokenizer(br.readLine());
            t[i] = Integer.parseInt(st.nextToken());
            p[i] = Integer.parseInt(st.nextToken());
        }

        for (int i = 0; i < n; i++) {
            if (i + t[i] <= n) {
                dp[i+t[i]] = Math.max(dp[i+t[i]], dp[i] + p[i]);
            }
            dp[i+1] = Math.max(dp[i+1], dp[i]);
        }
        
        System.out.println(dp[n]);
    }
}
```