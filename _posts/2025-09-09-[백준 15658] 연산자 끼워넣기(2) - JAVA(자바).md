---
title: "[백준 15658] 연산자 끼워넣기(2) - JAVA(자바)"
date: 2025-09-09
categories: [알고리즘]
tags: [알고리즘, 백준]
image:
  path: /assets/img/기본형3_java.png
---

### 문제

- [[백준] 15658](https://www.acmicpc.net/problem/15658)

![img](/assets/img/algorithm/백준15658_1.png)
![img](/assets/img/algorithm/백준15658_2.png)
<br /><br />

### 해결방법
- **백트래킹** 활용하기
  - dfs를 활용하여 모든 경우의 수 탐색
  - visited 배열 대신 각 연산자 개수를 담은 배열을 활용하여, 해당 연산자의 개수가 0이 될 때까지 재귀호출
      - 재귀호출 후에는 다시 해당 연산자의 개수를 복구

<br /><br />

### 코드

```java
import java.util.*;
import java.lang.*;
import java.io.*;

class Main {
    static int n;
    static int[] nums;
    static int[] operators;
    static int max = Integer.MIN_VALUE;
    static int min = Integer.MAX_VALUE;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        nums = new int[n];
        for (int i = 0; i < n; i++){
            nums[i] = Integer.parseInt(st.nextToken());
        }

        st = new StringTokenizer(br.readLine());
        operators = new int[4];
        for (int i = 0; i < 4; i++) {
            operators[i] = Integer.parseInt(st.nextToken());
        }

        dfs(1, nums[0]);

        System.out.print(max + "\n" + min);
    }

    private static void dfs(int depth, int result) {
        if (depth == n) {
            min = Math.min(min, result);
            max = Math.max(max, result);
            return;
        }

        for (int i = 0; i < 4; i++) {
            if (operators[i] == 0) continue;
            operators[i]--;
            switch (i) {
                case 0:
                    dfs(depth+1, result+nums[depth]);
                    break;
                case 1:
                    dfs(depth+1, result-nums[depth]);
                    break;
                case 2:
                    dfs(depth+1, result*nums[depth]);
                    break;
                case 3:
                    dfs(depth+1, result/nums[depth]);
                    break;
            }
            operators[i]++;
        }
    }
}
```